{"./":{"url":"./","title":"JavaCoder 源码进阶","keywords":"","body":"Java Coder 源码进阶 专注于源码阅读的专栏，从Java的源码到框架的源码的一个阅读专栏。 开始编辑日为2022年5月4日， 目前在编辑的系列是Java的基础类源码 没有具体编辑的目标，想到哪里更新到哪里。 powered by Gitbook该文件修订时间： 2022-05-04 01:12:54 "},"Java_Basic/data_type/":{"url":"Java_Basic/data_type/","title":"基本数据类型","keywords":"","body":"基本数据类型 在Java中有8个基本数据类型 整数型 int short byte long 浮点型 flot double 字符型 char 布尔型 boolean 这里要注意的是String不是基本数据类型，而是引用类型 powered by Gitbook该文件修订时间： 2022-05-04 01:36:14 "},"Java_Basic/data_type/Number_abstract.html":{"url":"Java_Basic/data_type/Number_abstract.html","title":"Number","keywords":"","body":"Number抽象类是所有数字类型都继承的一个抽象类，其中定义了几个抽象方法的API，用于快速拆装箱的方法。 public abstract int intValue(); public abstract long longValue(); public abstract float floatValue(); public abstract double doubleValue(); public byte byteValue() { return (byte)intValue(); } public short shortValue() { return (short)intValue(); } powered by Gitbook该文件修订时间： 2022-05-05 19:12:44 "},"Java_Basic/data_type/Integer.html":{"url":"Java_Basic/data_type/Integer.html","title":"Integer","keywords":"","body":"Integer类的继承关系 public final class Integer extends Number implements Comparable Integer类继承自Number的一个抽象类，和实现了Comparable接口。 成员变量 /** * A constant holding the minimum value an {@code int} can * have, -231. */ @Native public static final int MIN_VALUE = 0x80000000; /** * A constant holding the maximum value an {@code int} can * have, 231-1. */ @Native public static final int MAX_VALUE = 0x7fffffff; /** * The {@code Class} instance representing the primitive type * {@code int}. * * @since JDK1.1 */ @SuppressWarnings(\"unchecked\") public static final Class TYPE = (Class) Class.getPrimitiveClass(\"int\"); /** * All possible chars for representing a number as a String */ final static char[] digits = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' , 'h' , 'i' , 'j' , 'k' , 'l' , 'm' , 'n' , 'o' , 'p' , 'q' , 'r' , 's' , 't' , 'u' , 'v' , 'w' , 'x' , 'y' , 'z' }; MIN_VALUE 最小值 -231 MAX_VALUE 最大值 231-1. TYPE 表示他的基本数据类型是int digits 现在解释起来有点复杂，后面用到的时候在看 常用方法 parseInt public static int parseInt(String s) throws NumberFormatException { return parseInt(s,10); } 我们常用的ParseInt方法后面又会调用一次方法，parseInt(s, 10)方法，具体要进去看这个实现了。 public static int parseInt(String s, int radix) 看方法入参，radix属性当前为10，大概率是十进制的意思，继续看后续代码。 if (s == null) { throw new NumberFormatException(\"null\"); } if (radix Character.MAX_RADIX) { throw new NumberFormatException(\"radix \" + radix + \" greater than Character.MAX_RADIX\"); } 这里判断null值，和判断一下radix是否合法，大于等于2，小于等于36. int result = 0; boolean negative = false; int i = 0, len = s.length(); int limit = -Integer.MAX_VALUE; int multmin; int digit; 后面声明了几个变量，分别解读下目前已知含义的。 result 大概率是最后的结果值 negative 看意思是用来标记是否为负数 len 是s的长度 i 是用来遍历字符串的 其余的暂时不知道，后面看到在解释 if (len > 0) { // ... } else { throw NumberFormatException.forInputString(s); } return negative ? result : -result; 看后面的代码得知，猜测基本正确，根据negative判断是正负数，随后返回result变量。 后面进入If中看一下吧。 char firstChar = s.charAt(0); if (firstChar 获取了第一个字符，然后和0进行比较，按照ascii码对比，小于'0'字符的都是特殊字符。 这里主要的操作就是，处理了负数符号。 while (i 这里的while是用来遍历我们传入的字符串，方法一进入，调用了Character类的digit方法，随后一个*=radix也就是是10，然后result刚刚计算的值-=digit。所以这里要去看一下digit到底是什么。 public static int digit(char ch, int radix) { return digit((int)ch, radix); } 这里把ch变为了int，也就是ascii码对应的int。 public static int digit(int codePoint, int radix) { return CharacterData.of(codePoint).digit(codePoint, radix); } 当前显示根据of方法获取到了一个CharacterData类，这里进去看一下他的实现。 static final CharacterData of(int ch) { if (ch >>> 8 == 0) { // fast-path return CharacterDataLatin1.instance; } else { switch(ch >>> 16) { //plane 00-16 case(0): return CharacterData00.instance; case(1): return CharacterData01.instance; case(2): return CharacterData02.instance; case(14): return CharacterData0E.instance; case(15): // Private Use case(16): // Private Use return CharacterDataPrivateUse.instance; default: return CharacterDataUndefined.instance; } } } 这里方法比较简单，开始二进制右移8位，第一个if会进入，59右移8位=0所以会进入这个If判断，最终返回了一个CharacterDataLatin1类。回到上边的代码，去查看他的digit方法。 int digit(int ch, int radix) { int value = -1; // 判断radix的范围 if (radix >= Character.MIN_RADIX && radix > 5) & 0x1F; } else if ((val & 0xC00) == 0x00000C00) { // Java supradecimal digit value = (ch + ((val & 0x3E0) >> 5) & 0x1F) + 10; } } return (value getProperties得出一个数字，这个数字是什么无关紧要。 主要关注的是0x1F, 31的二进制是11111 &计算也就是，两位都为1，得1 这里也就是val转为二进制取出后五位，多余的可以不计，因为不是1都得0。 后面两个判断，一个是判断计算出来的kind等于9，第二个是跟3072进行&操作，计算出结果是3072为True。 对应两种value的计算方式。 计算公式是ch + ((val & 0x3E0) >> 5) & 0x1F，第二种是这个公式的结果+10。 注：0x3E0 = 992, 0x1F = 31 根据计算公式，可以计算一下这个value是多少。 ch=49 val=402667017 这是我的一个推算过程，最终结果为1。 最后就返回了一个1回去了，然后我们会到ParseInt方法接着往下看。 // 这里就是我们最后的数字了，至于怎么转换回来的 digit = Character.digit(s.charAt(i++),radix); if (digit result最终等于-1。最后return。 return negative ? result : -result; 由于negative为false所以最后返回的是-result。最后负负得正，返回了一个1。 powered by Gitbook该文件修订时间： 2022-05-05 19:12:42 "}}